// prebuilt/frontend/args.mycpp.cc: GENERATED by mycpp

#include "prebuilt/frontend/args.mycpp.h"
// BEGIN mycpp output

#include "mycpp/runtime.h"

GLOBAL_STR(str0, "(");
GLOBAL_STR(str1, ")");
GLOBAL_STR(str2, "_");
GLOBAL_STR(str3, "T");
GLOBAL_STR(str4, "F");
GLOBAL_STR(str5, "<IntControlFlow %s %s>");
GLOBAL_STR(str6, "<ValueControlFlow %s %s>");
GLOBAL_STR(str7, "");
GLOBAL_STR(str8, "");
GLOBAL_STR(str9, "\n<html>\n  <head>\n     <title>oil AST</title>\n     <style>\n      .n { color: brown }\n      .s { font-weight: bold }\n      .o { color: darkgreen }\n     </style>\n  </head>\n  <body>\n    <pre>\n");
GLOBAL_STR(str10, "\n    </pre>\n  </body>\n</html>\n    ");
GLOBAL_STR(str11, "n");
GLOBAL_STR(str12, "s");
GLOBAL_STR(str13, "o");
GLOBAL_STR(str14, "o");
GLOBAL_STR(str15, "o");
GLOBAL_STR(str16, "<span class=\"%s\">");
GLOBAL_STR(str17, "</span>");
GLOBAL_STR(str18, " ");
GLOBAL_STR(str19, "\n");
GLOBAL_STR(str20, " ");
GLOBAL_STR(str21, "]");
GLOBAL_STR(str22, " ");
GLOBAL_STR(str23, " ");
GLOBAL_STR(str24, "\n");
GLOBAL_STR(str25, "\n");
GLOBAL_STR(str26, " ");
GLOBAL_STR(str27, "%s%s: [");
GLOBAL_STR(str28, "\n");
GLOBAL_STR(str29, "\n");
GLOBAL_STR(str30, "%s]");
GLOBAL_STR(str31, "%s%s: ");
GLOBAL_STR(str32, "\n");
GLOBAL_STR(str33, "\n");
GLOBAL_STR(str34, " ");
GLOBAL_STR(str35, "UNTYPED any");
GLOBAL_STR(str36, " ");
GLOBAL_STR(str37, " ");
GLOBAL_STR(str38, " %s:");
GLOBAL_STR(str39, "UNTYPED any");
GLOBAL_STR(str40, "[");
GLOBAL_STR(str41, " ");
GLOBAL_STR(str42, "]");
GLOBAL_STR(str43, "\u001b[0;0m");
GLOBAL_STR(str44, "\u001b[1m");
GLOBAL_STR(str45, "\u001b[4m");
GLOBAL_STR(str46, "\u001b[7m");
GLOBAL_STR(str47, "\u001b[31m");
GLOBAL_STR(str48, "\u001b[32m");
GLOBAL_STR(str49, "\u001b[33m");
GLOBAL_STR(str50, "\u001b[34m");
GLOBAL_STR(str51, "&");
GLOBAL_STR(str52, "&amp;");
GLOBAL_STR(str53, "<");
GLOBAL_STR(str54, "&lt;");
GLOBAL_STR(str55, ">");
GLOBAL_STR(str56, "&gt;");
GLOBAL_STR(str57, "\\'\r\n\t\u0000");
GLOBAL_STR(str58, "$'");
GLOBAL_STR(str59, "'");
GLOBAL_STR(str60, "'");
GLOBAL_STR(str61, "");
GLOBAL_STR(str62, "'");
GLOBAL_STR(str63, "'");
GLOBAL_STR(str64, "");
GLOBAL_STR(str65, "'");
GLOBAL_STR(str66, "'");
GLOBAL_STR(str67, "");
GLOBAL_STR(str68, "\\");
GLOBAL_STR(str69, "\\\\");
GLOBAL_STR(str70, "'");
GLOBAL_STR(str71, "\\'");
GLOBAL_STR(str72, "\n");
GLOBAL_STR(str73, "\\n");
GLOBAL_STR(str74, "\r");
GLOBAL_STR(str75, "\\r");
GLOBAL_STR(str76, "\t");
GLOBAL_STR(str77, "\\t");
GLOBAL_STR(str78, "\u0000");
GLOBAL_STR(str79, "\\x00");
GLOBAL_STR(str80, "");
GLOBAL_STR(str81, "");
GLOBAL_STR(str82, "");
GLOBAL_STR(str83, "\\");
GLOBAL_STR(str84, "\\\\");
GLOBAL_STR(str85, "'");
GLOBAL_STR(str86, "\\'");
GLOBAL_STR(str87, "\n");
GLOBAL_STR(str88, "\\n");
GLOBAL_STR(str89, "\r");
GLOBAL_STR(str90, "\\r");
GLOBAL_STR(str91, "\t");
GLOBAL_STR(str92, "\\t");
GLOBAL_STR(str93, "\u0000");
GLOBAL_STR(str94, "\\x00");
GLOBAL_STR(str95, "<%s %r>");
GLOBAL_STR(str96, "%s, got %s");
GLOBAL_STR(str97, "-");
GLOBAL_STR(str98, "_");
GLOBAL_STR(str99, "<_Attributes %s>");
GLOBAL_STR(str100, "<args.Reader %r %d>");
GLOBAL_STR(str101, "expected argument to %r");
GLOBAL_STR(str102, "-");
GLOBAL_STR(str103, "expected integer after %s, got %r");
GLOBAL_STR(str104, "-");
GLOBAL_STR(str105, "got invalid integer for %s: %s");
GLOBAL_STR(str106, "-");
GLOBAL_STR(str107, "expected number after %r, got %r");
GLOBAL_STR(str108, "-");
GLOBAL_STR(str109, "got invalid float for %s: %s");
GLOBAL_STR(str110, "-");
GLOBAL_STR(str111, "got invalid argument %r to %r, expected one of: %s");
GLOBAL_STR(str112, "-");
GLOBAL_STR(str113, "|");
GLOBAL_STR(str114, "0");
GLOBAL_STR(str115, "F");
GLOBAL_STR(str116, "false");
GLOBAL_STR(str117, "False");
GLOBAL_STR(str118, "1");
GLOBAL_STR(str119, "T");
GLOBAL_STR(str120, "true");
GLOBAL_STR(str121, "Talse");
GLOBAL_STR(str122, "got invalid argument to boolean flag: %r");
GLOBAL_STR(str123, "-");
GLOBAL_STR(str124, "-");
GLOBAL_STR(str125, "Invalid option %r");
GLOBAL_STR(str126, "Expected argument for action");
GLOBAL_STR(str127, "Invalid action name %r");
GLOBAL_STR(str128, "--");
GLOBAL_STR(str129, "--");
GLOBAL_STR(str130, "=");
GLOBAL_STR(str131, "got invalid flag %r");
GLOBAL_STR(str132, "-");
GLOBAL_STR(str133, "0");
GLOBAL_STR(str134, "Z");
GLOBAL_STR(str135, "-");
GLOBAL_STR(str136, "doesn't accept flag %s");
GLOBAL_STR(str137, "-");
GLOBAL_STR(str138, "+");
GLOBAL_STR(str139, "+");
GLOBAL_STR(str140, "doesn't accept option %s");
GLOBAL_STR(str141, "+");
GLOBAL_STR(str142, "-");
GLOBAL_STR(str143, "--");
GLOBAL_STR(str144, "--");
GLOBAL_STR(str145, "got invalid flag %r");
GLOBAL_STR(str146, "-");
GLOBAL_STR(str147, "+");
GLOBAL_STR(str148, "got invalid flag %r");
GLOBAL_STR(str149, "-");

namespace vm {  // forward declare

  class ControlFlow;
  class IntControlFlow;
  class ValueControlFlow;
  class _Executor;
  class _AssignBuiltin;
  class _Builtin;
  class _Callable;
  class ctx_Redirect;
  class ctx_ProcessSub;
  class ctx_FlushStdout;

}  // forward declare namespace vm

namespace ansi {  // forward declare


}  // forward declare namespace ansi

namespace cgi {  // forward declare


}  // forward declare namespace cgi

namespace qsn {  // forward declare


}  // forward declare namespace qsn

namespace error {  // forward declare

  class _ErrorWithLocation;
  class Usage;
  class Runtime;
  class Parse;
  class FailGlob;
  class RedirectEval;
  class FatalRuntime;
  class Strict;
  class ErrExit;
  class Expr;
  class UserError;
  class AssertionErr;
  class TypeErrVerbose;
  class TypeErr;

}  // forward declare namespace error

namespace vm {  // declare

using id_kind_asdl::Id;
class ControlFlow {
 public:

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(0, sizeof(ControlFlow));
  }

  DISALLOW_COPY_AND_ASSIGN(ControlFlow)
};

class IntControlFlow {
 public:
  IntControlFlow(syntax_asdl::Token* token, int arg);
  bool IsReturn();
  bool IsBreak();
  bool IsContinue();
  int StatusCode();
  runtime_asdl::flow_t HandleLoop();
  syntax_asdl::Token* token;
  int arg;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(1, sizeof(IntControlFlow));
  }

  DISALLOW_COPY_AND_ASSIGN(IntControlFlow)
};

class ValueControlFlow {
 public:
  ValueControlFlow(syntax_asdl::Token* token, runtime_asdl::value_t* value);
  syntax_asdl::Token* token;
  runtime_asdl::value_t* value;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(2, sizeof(ValueControlFlow));
  }

  DISALLOW_COPY_AND_ASSIGN(ValueControlFlow)
};

void InitUnsafeArith(state::Mem* mem, word_eval::NormalWordEvaluator* word_ev, sh_expr_eval::UnsafeArith* unsafe_arith);
void InitCircularDeps(sh_expr_eval::ArithEvaluator* arith_ev, sh_expr_eval::BoolEvaluator* bool_ev, expr_eval::ExprEvaluator* expr_ev, word_eval::NormalWordEvaluator* word_ev, cmd_eval::CommandEvaluator* cmd_ev, vm::_Executor* shell_ex, prompt::Evaluator* prompt_ev, dev::Tracer* tracer);
class _Executor {
 public:
  _Executor();
  void CheckCircularDeps();
  int RunBuiltin(int builtin_id, cmd_value::Argv* cmd_val);
  int RunSimpleCommand(cmd_value::Argv* cmd_val, runtime_asdl::CommandStatus* cmd_st, bool do_fork, bool call_procs = true);
  int RunBackgroundJob(syntax_asdl::command_t* node);
  void RunPipeline(command::Pipeline* node, runtime_asdl::CommandStatus* status_out);
  int RunSubshell(syntax_asdl::command_t* node);
  Str* RunCommandSub(syntax_asdl::CommandSub* cs_part);
  Str* RunProcessSub(syntax_asdl::CommandSub* cs_part);
  bool PushRedirects(List<runtime_asdl::RedirValue*>* redirects);
  void PopRedirects(int num_redirects);
  void PushProcessSub();
  void PopProcessSub(runtime_asdl::StatusArray* compound_st);
  cmd_eval::CommandEvaluator* cmd_ev;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(1, sizeof(_Executor));
  }

  DISALLOW_COPY_AND_ASSIGN(_Executor)
};

class _AssignBuiltin {
 public:
  _AssignBuiltin();
  int Run(cmd_value::Assign* cmd_val);

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(0, sizeof(_AssignBuiltin));
  }

  DISALLOW_COPY_AND_ASSIGN(_AssignBuiltin)
};

class _Builtin {
 public:
  _Builtin();
  int Run(cmd_value::Argv* cmd_val);

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(0, sizeof(_Builtin));
  }

  DISALLOW_COPY_AND_ASSIGN(_Builtin)
};

class _Callable {
 public:
  _Callable();
  runtime_asdl::value_t* Call(typed_args::Reader* args);

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(0, sizeof(_Callable));
  }

  DISALLOW_COPY_AND_ASSIGN(_Callable)
};

class ctx_Redirect {
 public:
  ctx_Redirect(vm::_Executor* shell_ex, int num_redirects);
  ~ctx_Redirect();
  vm::_Executor* shell_ex;
  int num_redirects;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(1, sizeof(ctx_Redirect));
  }

  DISALLOW_COPY_AND_ASSIGN(ctx_Redirect)
};

class ctx_ProcessSub {
 public:
  ctx_ProcessSub(vm::_Executor* shell_ex, runtime_asdl::StatusArray* process_sub_status);
  ~ctx_ProcessSub();
  vm::_Executor* shell_ex;
  runtime_asdl::StatusArray* process_sub_status;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(2, sizeof(ctx_ProcessSub));
  }

  DISALLOW_COPY_AND_ASSIGN(ctx_ProcessSub)
};

class ctx_FlushStdout {
 public:
  ctx_FlushStdout();
  ~ctx_FlushStdout();

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(0, sizeof(ctx_FlushStdout));
  }

  DISALLOW_COPY_AND_ASSIGN(ctx_FlushStdout)
};



}  // declare namespace vm

namespace ansi {  // declare

extern Str* RESET;
extern Str* BOLD;
extern Str* UNDERLINE;
extern Str* REVERSE;
extern Str* RED;
extern Str* GREEN;
extern Str* YELLOW;
extern Str* BLUE;


}  // declare namespace ansi

namespace cgi {  // declare

Str* escape(Str* s);


}  // declare namespace cgi

namespace qsn {  // declare

extern int BIT8_UTF8;
extern int BIT8_U_ESCAPE;
extern int BIT8_X_ESCAPE;
extern int MUST_QUOTE;
bool _encode(Str* s, int bit8_display, mylib::BufWriter* buf);
Str* maybe_shell_encode(Str* s, int flags = 0);
Str* maybe_encode(Str* s, int bit8_display = BIT8_UTF8);
Str* encode(Str* s, int bit8_display = BIT8_UTF8);
void _encode_bytes_x(Str* s, mylib::BufWriter* buf);
extern int Ascii;
extern int Begin2;
extern int Begin3;
extern int Begin4;
extern int Cont;
extern int Invalid;
extern int Start;
extern int B2_1;
extern int B3_1;
extern int B4_1;
extern int B3_2;
extern int B4_2;
extern int B4_3;
bool EncodeRunes(Str* s, int bit8_display, mylib::BufWriter* buf);


}  // declare namespace qsn

namespace error {  // declare

using syntax_asdl::loc;
class _ErrorWithLocation {
 public:
  _ErrorWithLocation(Str* msg, syntax_asdl::loc_t* location);
  bool HasLocation();
  Str* UserErrorString();
  syntax_asdl::loc_t* location;
  Str* msg;
  
  static constexpr uint32_t field_mask() {
    return maskbit(offsetof(_ErrorWithLocation, location))
         | maskbit(offsetof(_ErrorWithLocation, msg));
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(_ErrorWithLocation));
  }

  DISALLOW_COPY_AND_ASSIGN(_ErrorWithLocation)
};

class Usage : public _ErrorWithLocation {
 public:
  Usage(Str* msg, syntax_asdl::loc_t* location);
  
  static constexpr uint32_t field_mask() {
    return _ErrorWithLocation::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(Usage));
  }

  DISALLOW_COPY_AND_ASSIGN(Usage)
};

class Runtime {
 public:
  Runtime(Str* msg);
  Str* UserErrorString();
  Str* msg;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(1, sizeof(Runtime));
  }

  DISALLOW_COPY_AND_ASSIGN(Runtime)
};

class Parse : public _ErrorWithLocation {
 public:
  Parse(Str* msg, syntax_asdl::loc_t* location);
  
  static constexpr uint32_t field_mask() {
    return _ErrorWithLocation::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(Parse));
  }

  DISALLOW_COPY_AND_ASSIGN(Parse)
};

class FailGlob : public _ErrorWithLocation {
 public:
  FailGlob(Str* msg, syntax_asdl::loc_t* location);
  
  static constexpr uint32_t field_mask() {
    return _ErrorWithLocation::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(FailGlob));
  }

  DISALLOW_COPY_AND_ASSIGN(FailGlob)
};

class RedirectEval : public _ErrorWithLocation {
 public:
  RedirectEval(Str* msg, syntax_asdl::loc_t* location);
  
  static constexpr uint32_t field_mask() {
    return _ErrorWithLocation::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(RedirectEval));
  }

  DISALLOW_COPY_AND_ASSIGN(RedirectEval)
};

class FatalRuntime : public _ErrorWithLocation {
 public:
  FatalRuntime(int exit_status, Str* msg, syntax_asdl::loc_t* location);
  int ExitStatus();

  int exit_status;
  
  static constexpr uint32_t field_mask() {
    return _ErrorWithLocation::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(FatalRuntime));
  }

  DISALLOW_COPY_AND_ASSIGN(FatalRuntime)
};

class Strict : public FatalRuntime {
 public:
  Strict(Str* msg, syntax_asdl::loc_t* location);
  
  static constexpr uint32_t field_mask() {
    return FatalRuntime::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(Strict));
  }

  DISALLOW_COPY_AND_ASSIGN(Strict)
};

class ErrExit : public FatalRuntime {
 public:
  ErrExit(int exit_status, Str* msg, syntax_asdl::loc_t* location, bool show_code = false);

  bool show_code;
  
  static constexpr uint32_t field_mask() {
    return FatalRuntime::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(ErrExit));
  }

  DISALLOW_COPY_AND_ASSIGN(ErrExit)
};

class Expr : public FatalRuntime {
 public:
  Expr(Str* msg, syntax_asdl::loc_t* location);
  
  static constexpr uint32_t field_mask() {
    return FatalRuntime::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(Expr));
  }

  DISALLOW_COPY_AND_ASSIGN(Expr)
};

class UserError : public FatalRuntime {
 public:
  UserError(int status, Str* msg, syntax_asdl::loc_t* location);
  
  static constexpr uint32_t field_mask() {
    return FatalRuntime::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(UserError));
  }

  DISALLOW_COPY_AND_ASSIGN(UserError)
};

class AssertionErr : public Expr {
 public:
  AssertionErr(Str* msg, syntax_asdl::loc_t* location);
  
  static constexpr uint32_t field_mask() {
    return Expr::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(AssertionErr));
  }

  DISALLOW_COPY_AND_ASSIGN(AssertionErr)
};

class TypeErrVerbose : public Expr {
 public:
  TypeErrVerbose(Str* msg, syntax_asdl::loc_t* location);
  
  static constexpr uint32_t field_mask() {
    return Expr::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(TypeErrVerbose));
  }

  DISALLOW_COPY_AND_ASSIGN(TypeErrVerbose)
};

class TypeErr : public TypeErrVerbose {
 public:
  TypeErr(runtime_asdl::value_t* actual_val, Str* msg, syntax_asdl::loc_t* location);
  
  static constexpr uint32_t field_mask() {
    return TypeErrVerbose::field_mask();
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(TypeErr));
  }

  DISALLOW_COPY_AND_ASSIGN(TypeErr)
};

[[noreturn]] void e_usage(Str* msg, syntax_asdl::loc_t* location);
[[noreturn]] void e_strict(Str* msg, syntax_asdl::loc_t* location);
[[noreturn]] void p_die(Str* msg, syntax_asdl::loc_t* location);
[[noreturn]] void e_die(Str* msg, syntax_asdl::loc_t* location = nullptr);
[[noreturn]] void e_die_status(int status, Str* msg, syntax_asdl::loc_t* location = nullptr);


}  // declare namespace error

namespace runtime {  // define

using hnode_asdl::hnode;
using hnode_asdl::color_t;
using hnode_asdl::color_e;
int NO_SPID = -1;

hnode::Record* NewRecord(Str* node_type) {
  StackRoots _roots({&node_type});

  return Alloc<hnode::Record>(node_type, Alloc<List<hnode_asdl::Field*>>(), false, str0, str1, Alloc<List<hnode_asdl::hnode_t*>>());
}

hnode::Leaf* NewLeaf(Str* s, hnode_asdl::color_t e_color) {
  StackRoots _roots({&s});

  if (s == nullptr) {
    return Alloc<hnode::Leaf>(str2, color_e::OtherConst);
  }
  else {
    return Alloc<hnode::Leaf>(s, e_color);
  }
}
Str* TRUE_STR = str3;
Str* FALSE_STR = str4;

}  // define namespace runtime

namespace vm {  // define

using id_kind_asdl::Id;
using runtime_asdl::CommandStatus;
using runtime_asdl::StatusArray;
using runtime_asdl::flow_e;
using runtime_asdl::flow_t;
using syntax_asdl::Token;

IntControlFlow::IntControlFlow(syntax_asdl::Token* token, int arg) {
  this->token = token;
  this->arg = arg;
}

bool IntControlFlow::IsReturn() {
  return this->token->id == Id::ControlFlow_Return;
}

bool IntControlFlow::IsBreak() {
  return this->token->id == Id::ControlFlow_Break;
}

bool IntControlFlow::IsContinue() {
  return this->token->id == Id::ControlFlow_Continue;
}

int IntControlFlow::StatusCode() {
  return (this->arg & 255);
}

runtime_asdl::flow_t IntControlFlow::HandleLoop() {
  if (this->IsBreak()) {
    this->arg -= 1;
    if (this->arg == 0) {
      return flow_e::Break;
    }
  }
  else {
    if (this->IsContinue()) {
      this->arg -= 1;
      if (this->arg == 0) {
        return flow_e::Nothing;
      }
    }
  }
  return flow_e::Raise;
}

ValueControlFlow::ValueControlFlow(syntax_asdl::Token* token, runtime_asdl::value_t* value) {
  this->token = token;
  this->value = value;
}

void InitUnsafeArith(state::Mem* mem, word_eval::NormalWordEvaluator* word_ev, sh_expr_eval::UnsafeArith* unsafe_arith) {
  StackRoots _roots({&mem, &word_ev, &unsafe_arith});

  mem->unsafe_arith = unsafe_arith;
  word_ev->unsafe_arith = unsafe_arith;
}

void InitCircularDeps(sh_expr_eval::ArithEvaluator* arith_ev, sh_expr_eval::BoolEvaluator* bool_ev, expr_eval::ExprEvaluator* expr_ev, word_eval::NormalWordEvaluator* word_ev, cmd_eval::CommandEvaluator* cmd_ev, vm::_Executor* shell_ex, prompt::Evaluator* prompt_ev, dev::Tracer* tracer) {
  StackRoots _roots({&arith_ev, &bool_ev, &expr_ev, &word_ev, &cmd_ev, &shell_ex, &prompt_ev, &tracer});

  arith_ev->word_ev = word_ev;
  bool_ev->word_ev = word_ev;
  if (expr_ev) {
    expr_ev->shell_ex = shell_ex;
    expr_ev->word_ev = word_ev;
  }
  word_ev->arith_ev = arith_ev;
  word_ev->expr_ev = expr_ev;
  word_ev->prompt_ev = prompt_ev;
  word_ev->shell_ex = shell_ex;
  cmd_ev->shell_ex = shell_ex;
  cmd_ev->arith_ev = arith_ev;
  cmd_ev->bool_ev = bool_ev;
  cmd_ev->expr_ev = expr_ev;
  cmd_ev->word_ev = word_ev;
  cmd_ev->tracer = tracer;
  shell_ex->cmd_ev = cmd_ev;
  prompt_ev->word_ev = word_ev;
  tracer->word_ev = word_ev;
  arith_ev->CheckCircularDeps();
  bool_ev->CheckCircularDeps();
  if (expr_ev) {
    expr_ev->CheckCircularDeps();
  }
  word_ev->CheckCircularDeps();
  cmd_ev->CheckCircularDeps();
  shell_ex->CheckCircularDeps();
  prompt_ev->CheckCircularDeps();
  tracer->CheckCircularDeps();
}

_Executor::_Executor() {
  this->cmd_ev = nullptr;
}

void _Executor::CheckCircularDeps() {
  ;  // pass
}

int _Executor::RunBuiltin(int builtin_id, cmd_value::Argv* cmd_val) {
  StackRoots _roots({&cmd_val});

  return 0;
}

int _Executor::RunSimpleCommand(cmd_value::Argv* cmd_val, runtime_asdl::CommandStatus* cmd_st, bool do_fork, bool call_procs) {
  StackRoots _roots({&cmd_val, &cmd_st});

  return 0;
}

int _Executor::RunBackgroundJob(syntax_asdl::command_t* node) {
  StackRoots _roots({&node});

  return 0;
}

void _Executor::RunPipeline(command::Pipeline* node, runtime_asdl::CommandStatus* status_out) {
  StackRoots _roots({&node, &status_out});

  ;  // pass
}

int _Executor::RunSubshell(syntax_asdl::command_t* node) {
  StackRoots _roots({&node});

  return 0;
}

Str* _Executor::RunCommandSub(syntax_asdl::CommandSub* cs_part) {
  StackRoots _roots({&cs_part});

  return str7;
}

Str* _Executor::RunProcessSub(syntax_asdl::CommandSub* cs_part) {
  StackRoots _roots({&cs_part});

  return str8;
}

bool _Executor::PushRedirects(List<runtime_asdl::RedirValue*>* redirects) {
  StackRoots _roots({&redirects});

  return true;
}

void _Executor::PopRedirects(int num_redirects) {
  ;  // pass
}

void _Executor::PushProcessSub() {
  ;  // pass
}

void _Executor::PopProcessSub(runtime_asdl::StatusArray* compound_st) {
  StackRoots _roots({&compound_st});

  ;  // pass
}

_AssignBuiltin::_AssignBuiltin() {
  ;  // pass
}

int _AssignBuiltin::Run(cmd_value::Assign* cmd_val) {
  StackRoots _roots({&cmd_val});

  FAIL(kNotImplemented);  // Python NotImplementedError
}

_Builtin::_Builtin() {
  ;  // pass
}

int _Builtin::Run(cmd_value::Argv* cmd_val) {
  StackRoots _roots({&cmd_val});

  FAIL(kNotImplemented);  // Python NotImplementedError
}

_Callable::_Callable() {
  ;  // pass
}

runtime_asdl::value_t* _Callable::Call(typed_args::Reader* args) {
  StackRoots _roots({&args});

  FAIL(kNotImplemented);  // Python NotImplementedError
}

ctx_Redirect::ctx_Redirect(vm::_Executor* shell_ex, int num_redirects) {
  this->shell_ex = shell_ex;
  this->num_redirects = num_redirects;
}

ctx_Redirect::~ctx_Redirect(){
  this->shell_ex->PopRedirects(this->num_redirects);
}

ctx_ProcessSub::ctx_ProcessSub(vm::_Executor* shell_ex, runtime_asdl::StatusArray* process_sub_status) {
  shell_ex->PushProcessSub();
  this->shell_ex = shell_ex;
  this->process_sub_status = process_sub_status;
}

ctx_ProcessSub::~ctx_ProcessSub(){
  this->shell_ex->PopProcessSub(this->process_sub_status);
}

ctx_FlushStdout::ctx_FlushStdout() {
  ;  // pass
}

ctx_FlushStdout::~ctx_FlushStdout(){
  pyos::FlushStdout();
}

}  // define namespace vm

namespace format {  // define

using hnode_asdl::hnode;
using hnode_asdl::hnode_e;
using hnode_asdl::hnode_t;
using hnode_asdl::color_e;
using hnode_asdl::color_t;

format::ColorOutput* DetectConsoleOutput(mylib::Writer* f) {
  StackRoots _roots({&f});

  if (f->isatty()) {
    return Alloc<AnsiOutput>(f);
  }
  else {
    return Alloc<TextOutput>(f);
  }
}

ColorOutput::ColorOutput(mylib::Writer* f) {
  this->f = f;
  this->num_chars = 0;
}

format::ColorOutput* ColorOutput::NewTempBuffer() {
  FAIL(kNotImplemented);  // Python NotImplementedError
}

void ColorOutput::FileHeader() {
  ;  // pass
}

void ColorOutput::FileFooter() {
  ;  // pass
}

void ColorOutput::PushColor(hnode_asdl::color_t e_color) {
  FAIL(kNotImplemented);  // Python NotImplementedError
}

void ColorOutput::PopColor() {
  FAIL(kNotImplemented);  // Python NotImplementedError
}

void ColorOutput::write(Str* s) {
  StackRoots _roots({&s});

  this->f->write(s);
  this->num_chars += len(s);
}

void ColorOutput::WriteRaw(Tuple2<Str*, int>* raw) {
  Str* s = nullptr;
  int num_chars;
  StackRoots _roots({&raw, &s});

  Tuple2<Str*, int>* tup0 = raw;
  s = tup0->at0();
  num_chars = tup0->at1();
  this->f->write(s);
  this->num_chars += num_chars;
}

int ColorOutput::NumChars() {
  return this->num_chars;
}

Tuple2<Str*, int> ColorOutput::GetRaw() {
  mylib::BufWriter* f = static_cast<mylib::BufWriter*>(this->f);
  return Tuple2<Str*, int>(f->getvalue(), this->num_chars);
}

TextOutput::TextOutput(mylib::Writer* f) : ColorOutput(f) {
}

format::TextOutput* TextOutput::NewTempBuffer() {
  return Alloc<TextOutput>(Alloc<mylib::BufWriter>());
}

void TextOutput::PushColor(hnode_asdl::color_t e_color) {
  ;  // pass
}

void TextOutput::PopColor() {
  ;  // pass
}

HtmlOutput::HtmlOutput(mylib::Writer* f) : ColorOutput(f) {
}

format::HtmlOutput* HtmlOutput::NewTempBuffer() {
  return Alloc<HtmlOutput>(Alloc<mylib::BufWriter>());
}

void HtmlOutput::FileHeader() {
  this->f->write(str9);
}

void HtmlOutput::FileFooter() {
  this->f->write(str10);
}

void HtmlOutput::PushColor(hnode_asdl::color_t e_color) {
  Str* css_class = nullptr;
  StackRoots _roots({&css_class});

  if (e_color == color_e::TypeName) {
    css_class = str11;
  }
  else {
    if (e_color == color_e::StringConst) {
      css_class = str12;
    }
    else {
      if (e_color == color_e::OtherConst) {
        css_class = str13;
      }
      else {
        if (e_color == color_e::External) {
          css_class = str14;
        }
        else {
          if (e_color == color_e::UserType) {
            css_class = str15;
          }
          else {
            assert(0);  // AssertionError
          }
        }
      }
    }
  }
  this->f->write(StrFormat("<span class=\"%s\">", css_class));
}

void HtmlOutput::PopColor() {
  this->f->write(str17);
}

void HtmlOutput::write(Str* s) {
  StackRoots _roots({&s});

  this->f->write(cgi::escape(s));
  this->num_chars += len(s);
}

AnsiOutput::AnsiOutput(mylib::Writer* f) : ColorOutput(f) {
}

format::AnsiOutput* AnsiOutput::NewTempBuffer() {
  return Alloc<AnsiOutput>(Alloc<mylib::BufWriter>());
}

void AnsiOutput::PushColor(hnode_asdl::color_t e_color) {
  if (e_color == color_e::TypeName) {
    this->f->write(ansi::YELLOW);
  }
  else {
    if (e_color == color_e::StringConst) {
      this->f->write(ansi::BOLD);
    }
    else {
      if (e_color == color_e::OtherConst) {
        this->f->write(ansi::GREEN);
      }
      else {
        if (e_color == color_e::External) {
          this->f->write(str_concat(ansi::BOLD, ansi::BLUE));
        }
        else {
          if (e_color == color_e::UserType) {
            this->f->write(ansi::GREEN);
          }
          else {
            assert(0);  // AssertionError
          }
        }
      }
    }
  }
}

void AnsiOutput::PopColor() {
  this->f->write(ansi::RESET);
}
int INDENT = 2;

_PrettyPrinter::_PrettyPrinter(int max_col) {
  this->max_col = max_col;
}

bool _PrettyPrinter::_PrintWrappedArray(List<hnode_asdl::hnode_t*>* array, int prefix_len, format::ColorOutput* f, int indent) {
  bool all_fit;
  int chars_so_far;
  int i;
  format::ColorOutput* single_f = nullptr;
  Str* s = nullptr;
  int num_chars;
  StackRoots _roots({&array, &f, &single_f, &s});

  all_fit = true;
  chars_so_far = prefix_len;
  i = 0;
  for (ListIter<hnode_asdl::hnode_t*> it(array); !it.Done(); it.Next(), ++i) {
    hnode_asdl::hnode_t* val = it.Value();
    StackRoots _for({&val  });
    if (i != 0) {
      f->write(str18);
    }
    single_f = f->NewTempBuffer();
    if (_TrySingleLine(val, single_f, (this->max_col - chars_so_far))) {
      Tuple2<Str*, int> tup1 = single_f->GetRaw();
      s = tup1.at0();
      num_chars = tup1.at1();
      f->WriteRaw((Alloc<Tuple2<Str*, int>>(s, num_chars)));
      chars_so_far += single_f->NumChars();
    }
    else {
      f->write(str19);
      this->PrintNode(val, f, (indent + INDENT));
      chars_so_far = 0;
      all_fit = false;
    }
  }
  return all_fit;
}

bool _PrettyPrinter::_PrintWholeArray(List<hnode_asdl::hnode_t*>* array, int prefix_len, format::ColorOutput* f, int indent) {
  bool all_fit;
  List<Tuple2<Str*, int>*>* pieces = nullptr;
  int chars_so_far;
  format::ColorOutput* single_f = nullptr;
  Str* s = nullptr;
  int num_chars;
  int i;
  StackRoots _roots({&array, &f, &pieces, &single_f, &s});

  all_fit = true;
  pieces = Alloc<List<Tuple2<Str*, int>*>>();
  chars_so_far = prefix_len;
  for (ListIter<hnode_asdl::hnode_t*> it(array); !it.Done(); it.Next()) {
    hnode_asdl::hnode_t* item = it.Value();
    StackRoots _for({&item  });
    single_f = f->NewTempBuffer();
    if (_TrySingleLine(item, single_f, (this->max_col - chars_so_far))) {
      Tuple2<Str*, int> tup2 = single_f->GetRaw();
      s = tup2.at0();
      num_chars = tup2.at1();
      pieces->append((Alloc<Tuple2<Str*, int>>(s, num_chars)));
      chars_so_far += single_f->NumChars();
    }
    else {
      all_fit = false;
      break;
    }
  }
  if (all_fit) {
    i = 0;
    for (ListIter<Tuple2<Str*, int>*> it(pieces); !it.Done(); it.Next(), ++i) {
      Tuple2<Str*, int>* p = it.Value();
      StackRoots _for({&p    });
      if (i != 0) {
        f->write(str20);
      }
      f->WriteRaw(p);
    }
    f->write(str21);
  }
  return all_fit;
}

void _PrettyPrinter::_PrintRecord(hnode::Record* node, format::ColorOutput* f, int indent) {
  Str* ind = nullptr;
  Str* prefix = nullptr;
  int prefix_len;
  bool all_fit;
  Str* name = nullptr;
  hnode_asdl::hnode_t* val = nullptr;
  Str* ind1 = nullptr;
  hnode_asdl::hnode_t* UP_val = nullptr;
  int tag;
  Str* name_str = nullptr;
  format::ColorOutput* single_f = nullptr;
  Str* s = nullptr;
  int num_chars;
  StackRoots _roots({&node, &f, &ind, &prefix, &name, &val, &ind1, &UP_val, &name_str, &single_f, &s});

  ind = str_repeat(str22, indent);
  if (node->abbrev) {
    prefix = str_concat(ind, node->left);
    f->write(prefix);
    if (len(node->node_type)) {
      f->PushColor(color_e::TypeName);
      f->write(node->node_type);
      f->PopColor();
      f->write(str23);
    }
    prefix_len = ((len(prefix) + len(node->node_type)) + 1);
    all_fit = this->_PrintWrappedArray(node->unnamed_fields, prefix_len, f, indent);
    if (!all_fit) {
      f->write(str24);
      f->write(ind);
    }
    f->write(node->right);
  }
  else {
    f->write(str_concat(ind, node->left));
    f->PushColor(color_e::TypeName);
    f->write(node->node_type);
    f->PopColor();
    f->write(str25);
    for (ListIter<hnode_asdl::Field*> it(node->fields); !it.Done(); it.Next()) {
      hnode_asdl::Field* field = it.Value();
      StackRoots _for({&field    });
      name = field->name;
      val = field->val;
      ind1 = str_repeat(str26, (indent + INDENT));
      UP_val = val;
      tag = val->tag();
      if (tag == hnode_e::Array) {
        hnode::Array* val = static_cast<hnode::Array*>(UP_val);
        name_str = StrFormat("%s%s: [", ind1, name);
        f->write(name_str);
        prefix_len = len(name_str);
        if (!this->_PrintWholeArray(val->children, prefix_len, f, indent)) {
          f->write(str28);
          for (ListIter<hnode_asdl::hnode_t*> it(val->children); !it.Done(); it.Next()) {
            hnode_asdl::hnode_t* child = it.Value();
            StackRoots _for({&child          });
            this->PrintNode(child, f, ((indent + INDENT) + INDENT));
            f->write(str29);
          }
          f->write(StrFormat("%s]", ind1));
        }
      }
      else {
        name_str = StrFormat("%s%s: ", ind1, name);
        f->write(name_str);
        prefix_len = len(name_str);
        single_f = f->NewTempBuffer();
        if (_TrySingleLine(val, single_f, (this->max_col - prefix_len))) {
          Tuple2<Str*, int> tup3 = single_f->GetRaw();
          s = tup3.at0();
          num_chars = tup3.at1();
          f->WriteRaw((Alloc<Tuple2<Str*, int>>(s, num_chars)));
        }
        else {
          f->write(str32);
          this->PrintNode(val, f, ((indent + INDENT) + INDENT));
        }
      }
      f->write(str33);
    }
    f->write(str_concat(ind, node->right));
  }
}

void _PrettyPrinter::PrintNode(hnode_asdl::hnode_t* node, format::ColorOutput* f, int indent) {
  Str* ind = nullptr;
  format::ColorOutput* single_f = nullptr;
  Str* s = nullptr;
  int num_chars;
  hnode_asdl::hnode_t* UP_node = nullptr;
  int tag;
  StackRoots _roots({&node, &f, &ind, &single_f, &s, &UP_node});

  ind = str_repeat(str34, indent);
  single_f = f->NewTempBuffer();
  single_f->write(ind);
  if (_TrySingleLine(node, single_f, (this->max_col - indent))) {
    Tuple2<Str*, int> tup4 = single_f->GetRaw();
    s = tup4.at0();
    num_chars = tup4.at1();
    f->WriteRaw((Alloc<Tuple2<Str*, int>>(s, num_chars)));
    return ;
  }
  UP_node = node;
  tag = node->tag();
  if (tag == hnode_e::Leaf) {
    hnode::Leaf* node = static_cast<hnode::Leaf*>(UP_node);
    f->PushColor(node->color);
    f->write(qsn::maybe_encode(node->s));
    f->PopColor();
  }
  else {
    if (tag == hnode_e::External) {
      hnode::External* node = static_cast<hnode::External*>(UP_node);
      f->PushColor(color_e::External);
      // if not PYTHON
      {
        f->write(str35);
      }
      // endif MYCPP
      f->PopColor();
    }
    else {
      if (tag == hnode_e::Record) {
        hnode::Record* node = static_cast<hnode::Record*>(UP_node);
        this->_PrintRecord(node, f, indent);
      }
      else {
        assert(0);  // AssertionError
      }
    }
  }
}

bool _TrySingleLineObj(hnode::Record* node, format::ColorOutput* f, int max_chars) {
  int i;
  StackRoots _roots({&node, &f});

  f->write(node->left);
  if (node->abbrev) {
    if (len(node->node_type)) {
      f->PushColor(color_e::TypeName);
      f->write(node->node_type);
      f->PopColor();
      f->write(str36);
    }
    i = 0;
    for (ListIter<hnode_asdl::hnode_t*> it(node->unnamed_fields); !it.Done(); it.Next(), ++i) {
      hnode_asdl::hnode_t* val = it.Value();
      StackRoots _for({&val    });
      if (i != 0) {
        f->write(str37);
      }
      if (!_TrySingleLine(val, f, max_chars)) {
        return false;
      }
    }
  }
  else {
    f->PushColor(color_e::TypeName);
    f->write(node->node_type);
    f->PopColor();
    for (ListIter<hnode_asdl::Field*> it(node->fields); !it.Done(); it.Next()) {
      hnode_asdl::Field* field = it.Value();
      StackRoots _for({&field    });
      f->write(StrFormat(" %s:", field->name));
      if (!_TrySingleLine(field->val, f, max_chars)) {
        return false;
      }
    }
  }
  f->write(node->right);
  return true;
}

bool _TrySingleLine(hnode_asdl::hnode_t* node, format::ColorOutput* f, int max_chars) {
  hnode_asdl::hnode_t* UP_node = nullptr;
  int tag;
  int i;
  int num_chars_so_far;
  StackRoots _roots({&node, &f, &UP_node});

  UP_node = node;
  tag = node->tag();
  if (tag == hnode_e::Leaf) {
    hnode::Leaf* node = static_cast<hnode::Leaf*>(UP_node);
    f->PushColor(node->color);
    f->write(qsn::maybe_encode(node->s));
    f->PopColor();
  }
  else {
    if (tag == hnode_e::External) {
      hnode::External* node = static_cast<hnode::External*>(UP_node);
      f->PushColor(color_e::External);
      // if not PYTHON
      {
        f->write(str39);
      }
      // endif MYCPP
      f->PopColor();
    }
    else {
      if (tag == hnode_e::Array) {
        hnode::Array* node = static_cast<hnode::Array*>(UP_node);
        f->write(str40);
        i = 0;
        for (ListIter<hnode_asdl::hnode_t*> it(node->children); !it.Done(); it.Next(), ++i) {
          hnode_asdl::hnode_t* item = it.Value();
          StackRoots _for({&item        });
          if (i != 0) {
            f->write(str41);
          }
          if (!_TrySingleLine(item, f, max_chars)) {
            return false;
          }
        }
        f->write(str42);
      }
      else {
        if (tag == hnode_e::Record) {
          hnode::Record* node = static_cast<hnode::Record*>(UP_node);
          return _TrySingleLineObj(node, f, max_chars);
        }
        else {
          assert(0);  // AssertionError
        }
      }
    }
  }
  num_chars_so_far = f->NumChars();
  if (num_chars_so_far > max_chars) {
    return false;
  }
  return true;
}

void PrintTree(hnode_asdl::hnode_t* node, format::ColorOutput* f) {
  format::_PrettyPrinter* pp = nullptr;
  StackRoots _roots({&node, &f, &pp});

  pp = Alloc<_PrettyPrinter>(100);
  pp->PrintNode(node, f, 0);
}

}  // define namespace format

namespace ansi {  // define

Str* RESET = str43;
Str* BOLD = str44;
Str* UNDERLINE = str45;
Str* REVERSE = str46;
Str* RED = str47;
Str* GREEN = str48;
Str* YELLOW = str49;
Str* BLUE = str50;

}  // define namespace ansi

namespace cgi {  // define


Str* escape(Str* s) {
  StackRoots _roots({&s});

  s = s->replace(str51, str52);
  s = s->replace(str53, str54);
  s = s->replace(str55, str56);
  return s;
}

}  // define namespace cgi

namespace qsn {  // define

int BIT8_UTF8 = 0;
int BIT8_U_ESCAPE = 1;
int BIT8_X_ESCAPE = 2;
int MUST_QUOTE = 4;

bool _encode(Str* s, int bit8_display, mylib::BufWriter* buf) {
  StackRoots _roots({&s, &buf});

  if (bit8_display == BIT8_X_ESCAPE) {
    _encode_bytes_x(s, buf);
    return true;
  }
  else {
    return EncodeRunes(s, bit8_display, buf);
  }
}

Str* maybe_shell_encode(Str* s, int flags) {
  int quote;
  int must_quote;
  int bit8_display;
  List<Str*>* parts = nullptr;
  mylib::BufWriter* buf = nullptr;
  bool valid_utf8;
  Str* prefix = nullptr;
  StackRoots _roots({&s, &parts, &buf, &prefix});

  quote = 0;
  must_quote = (flags & 4);
  bit8_display = (flags & 3);
  if (len(s) == 0) {
    quote = 1;
  }
  else {
    for (StrIter it(s); !it.Done(); it.Next()) {
      Str* ch = it.Value();
      StackRoots _for({&ch    });
      if ((!must_quote and IsPlainChar(ch))) {
        continue;
      }
      quote = 1;
      if ((str_contains(str57, ch) or IsUnprintableLow(ch))) {
        quote = 2;
        break;
      }
    }
  }
  if (quote == 0) {
    return s;
  }
  parts = Alloc<List<Str*>>();
  buf = Alloc<mylib::BufWriter>();
  valid_utf8 = _encode(s, bit8_display, buf);
  parts->append(buf->getvalue());
  if ((!valid_utf8 or quote == 2)) {
    prefix = str58;
  }
  else {
    prefix = str59;
  }
  parts->append(str60);
  return str_concat(prefix, str61->join(parts));
}

Str* maybe_encode(Str* s, int bit8_display) {
  int quote;
  List<Str*>* parts = nullptr;
  mylib::BufWriter* buf = nullptr;
  StackRoots _roots({&s, &parts, &buf});

  quote = 0;
  if (len(s) == 0) {
    quote = 1;
  }
  else {
    for (StrIter it(s); !it.Done(); it.Next()) {
      Str* ch = it.Value();
      StackRoots _for({&ch    });
      if (IsPlainChar(ch)) {
        continue;
      }
      quote = 1;
    }
  }
  if (!quote) {
    return s;
  }
  parts = Alloc<List<Str*>>();
  parts->append(str62);
  buf = Alloc<mylib::BufWriter>();
  _encode(s, bit8_display, buf);
  parts->append(buf->getvalue());
  parts->append(str63);
  return str64->join(parts);
}

Str* encode(Str* s, int bit8_display) {
  List<Str*>* parts = nullptr;
  mylib::BufWriter* buf = nullptr;
  StackRoots _roots({&s, &parts, &buf});

  parts = Alloc<List<Str*>>();
  parts->append(str65);
  buf = Alloc<mylib::BufWriter>();
  _encode(s, bit8_display, buf);
  parts->append(buf->getvalue());
  parts->append(str66);
  return str67->join(parts);
}

void _encode_bytes_x(Str* s, mylib::BufWriter* buf) {
  Str* part = nullptr;
  StackRoots _roots({&s, &buf, &part});

  for (StrIter it(s); !it.Done(); it.Next()) {
    Str* byte = it.Value();
    StackRoots _for({&byte  });
    if (str_equals(byte, str68)) {
      part = str69;
    }
    else {
      if (str_equals(byte, str70)) {
        part = str71;
      }
      else {
        if (str_equals(byte, str72)) {
          part = str73;
        }
        else {
          if (str_equals(byte, str74)) {
            part = str75;
          }
          else {
            if (str_equals(byte, str76)) {
              part = str77;
            }
            else {
              if (str_equals(byte, str78)) {
                part = str79;
              }
              else {
                if (IsUnprintableLow(byte)) {
                  part = XEscape(byte);
                }
                else {
                  if (IsUnprintableHigh(byte)) {
                    part = XEscape(byte);
                  }
                  else {
                    part = byte;
                  }
                }
              }
            }
          }
        }
      }
    }
    buf->write(part);
  }
}
int Ascii = 0;
int Begin2 = 1;
int Begin3 = 2;
int Begin4 = 3;
int Cont = 4;
int Invalid = 5;
int Start = 0;
int B2_1 = 1;
int B3_1 = 2;
int B4_1 = 3;
int B3_2 = 4;
int B4_2 = 5;
int B4_3 = 6;

bool EncodeRunes(Str* s, int bit8_display, mylib::BufWriter* buf) {
  bool valid_utf8;
  int state;
  Str* r1 = nullptr;
  Str* r2 = nullptr;
  Str* r3 = nullptr;
  int b;
  int typ;
  Str* out = nullptr;
  int rune;
  StackRoots _roots({&s, &buf, &r1, &r2, &r3, &out});

  valid_utf8 = true;
  state = Start;
  r1 = str80;
  r2 = str81;
  r3 = str82;
  for (StrIter it(s); !it.Done(); it.Next()) {
    Str* byte = it.Value();
    StackRoots _for({&byte  });
    b = ord(byte);
    if (b < 127) {
      typ = Ascii;
    }
    else {
      if ((b >> 6) == 2) {
        typ = Cont;
      }
      else {
        if ((b >> 5) == 6) {
          typ = Begin2;
        }
        else {
          if ((b >> 4) == 14) {
            typ = Begin3;
          }
          else {
            if ((b >> 3) == 30) {
              typ = Begin4;
            }
            else {
              typ = Invalid;
            }
          }
        }
      }
    }
    if (typ != Cont) {
      if (state >= B2_1) {
        valid_utf8 = false;
        buf->write(XEscape(r1));
      }
      if (state >= B3_2) {
        buf->write(XEscape(r2));
      }
      if (state >= B4_3) {
        buf->write(XEscape(r3));
      }
    }
    if (typ == Ascii) {
      state = Start;
      if (str_equals(byte, str83)) {
        out = str84;
      }
      else {
        if (str_equals(byte, str85)) {
          out = str86;
        }
        else {
          if (str_equals(byte, str87)) {
            out = str88;
          }
          else {
            if (str_equals(byte, str89)) {
              out = str90;
            }
            else {
              if (str_equals(byte, str91)) {
                out = str92;
              }
              else {
                if (str_equals(byte, str93)) {
                  out = str94;
                }
                else {
                  if (IsUnprintableLow(byte)) {
                    if (bit8_display == BIT8_U_ESCAPE) {
                      out = UEscape(ord(byte));
                    }
                    else {
                      out = XEscape(byte);
                    }
                  }
                  else {
                    out = byte;
                  }
                }
              }
            }
          }
        }
      }
      buf->write(out);
    }
    else {
      if (typ == Begin2) {
        state = B2_1;
        r1 = byte;
      }
      else {
        if (typ == Begin3) {
          state = B3_1;
          r1 = byte;
        }
        else {
          if (typ == Begin4) {
            state = B4_1;
            r1 = byte;
          }
          else {
            if (typ == Invalid) {
              state = Start;
              buf->write(XEscape(byte));
              valid_utf8 = false;
            }
            else {
              if (typ == Cont) {
                if (state == Start) {
                  buf->write(XEscape(byte));
                  valid_utf8 = false;
                }
                else {
                  if (state == B2_1) {
                    if (bit8_display == BIT8_UTF8) {
                      out = str_concat(r1, byte);
                    }
                    else {
                      rune = (ord(byte) & 63);
                      rune |= ((ord(r1) & 31) << 6);
                      out = UEscape(rune);
                    }
                    buf->write(out);
                    state = Start;
                  }
                  else {
                    if (state == B3_1) {
                      r2 = byte;
                      state = B3_2;
                    }
                    else {
                      if (state == B3_2) {
                        if (bit8_display == BIT8_UTF8) {
                          out = str_concat(str_concat(r1, r2), byte);
                        }
                        else {
                          rune = (ord(byte) & 63);
                          rune |= ((ord(r2) & 63) << 6);
                          rune |= ((ord(r1) & 15) << 12);
                          out = UEscape(rune);
                        }
                        buf->write(out);
                        state = Start;
                      }
                      else {
                        if (state == B4_1) {
                          r2 = byte;
                          state = B4_2;
                        }
                        else {
                          if (state == B4_2) {
                            r3 = byte;
                            state = B4_3;
                          }
                          else {
                            if (state == B4_3) {
                              if (bit8_display == BIT8_UTF8) {
                                out = str_concat(str_concat(str_concat(r1, r2), r3), byte);
                              }
                              else {
                                rune = (ord(byte) & 63);
                                rune |= ((ord(r3) & 63) << 6);
                                rune |= ((ord(r2) & 63) << 12);
                                rune |= ((ord(r1) & 7) << 18);
                                out = UEscape(rune);
                              }
                              buf->write(out);
                              state = Start;
                            }
                            else {
                              assert(0);  // AssertionError
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              else {
                assert(0);  // AssertionError
              }
            }
          }
        }
      }
    }
  }
  if (state >= B2_1) {
    valid_utf8 = false;
    buf->write(XEscape(r1));
  }
  if (state >= B3_2) {
    buf->write(XEscape(r2));
  }
  if (state >= B4_3) {
    buf->write(XEscape(r3));
  }
  return valid_utf8;
}

}  // define namespace qsn

namespace error {  // define

using syntax_asdl::loc_e;
using syntax_asdl::loc;
using runtime_asdl::value_t;

_ErrorWithLocation::_ErrorWithLocation(Str* msg, syntax_asdl::loc_t* location) {
  this->msg = msg;
  if (location == nullptr) {
    this->location = loc::Missing;
  }
  else {
    this->location = location;
  }
}

bool _ErrorWithLocation::HasLocation() {
  return this->location->tag() != loc_e::Missing;
}

Str* _ErrorWithLocation::UserErrorString() {
  return this->msg;
}

Usage::Usage(Str* msg, syntax_asdl::loc_t* location) : _ErrorWithLocation(msg, location) {
}

Runtime::Runtime(Str* msg) {
  this->msg = msg;
}

Str* Runtime::UserErrorString() {
  return this->msg;
}

Parse::Parse(Str* msg, syntax_asdl::loc_t* location) : _ErrorWithLocation(msg, location) {
}

FailGlob::FailGlob(Str* msg, syntax_asdl::loc_t* location) : _ErrorWithLocation(msg, location) {
}

RedirectEval::RedirectEval(Str* msg, syntax_asdl::loc_t* location) : _ErrorWithLocation(msg, location) {
}

FatalRuntime::FatalRuntime(int exit_status, Str* msg, syntax_asdl::loc_t* location) : _ErrorWithLocation(msg, location) {
  this->exit_status = exit_status;
}

int FatalRuntime::ExitStatus() {
  return this->exit_status;
}

Strict::Strict(Str* msg, syntax_asdl::loc_t* location) : FatalRuntime(1, msg, location) {
}

ErrExit::ErrExit(int exit_status, Str* msg, syntax_asdl::loc_t* location, bool show_code) : FatalRuntime(exit_status, msg, location) {
  this->show_code = show_code;
}

Expr::Expr(Str* msg, syntax_asdl::loc_t* location) : FatalRuntime(3, msg, location) {
}

UserError::UserError(int status, Str* msg, syntax_asdl::loc_t* location) : FatalRuntime(status, msg, location) {
}

AssertionErr::AssertionErr(Str* msg, syntax_asdl::loc_t* location) : Expr(msg, location) {
}

TypeErrVerbose::TypeErrVerbose(Str* msg, syntax_asdl::loc_t* location) : Expr(msg, location) {
}

TypeErr::TypeErr(runtime_asdl::value_t* actual_val, Str* msg, syntax_asdl::loc_t* location) : TypeErrVerbose(StrFormat("%s, got %s", msg, ui::ValType(actual_val)), location) {
}

[[noreturn]] void e_usage(Str* msg, syntax_asdl::loc_t* location) {
  StackRoots _roots({&msg, &location});

  throw Alloc<Usage>(msg, location);
}

[[noreturn]] void e_strict(Str* msg, syntax_asdl::loc_t* location) {
  StackRoots _roots({&msg, &location});

  throw Alloc<Strict>(msg, location);
}

[[noreturn]] void p_die(Str* msg, syntax_asdl::loc_t* location) {
  StackRoots _roots({&msg, &location});

  throw Alloc<Parse>(msg, location);
}

[[noreturn]] void e_die(Str* msg, syntax_asdl::loc_t* location) {
  StackRoots _roots({&msg, &location});

  throw Alloc<FatalRuntime>(1, msg, location);
}

[[noreturn]] void e_die_status(int status, Str* msg, syntax_asdl::loc_t* location) {
  StackRoots _roots({&msg, &location});

  throw Alloc<FatalRuntime>(status, msg, location);
}

}  // define namespace error

namespace args {  // define

using syntax_asdl::loc;
using syntax_asdl::loc_t;
using syntax_asdl::CompoundWord;
using runtime_asdl::value;
using runtime_asdl::value_e;
using runtime_asdl::value_t;
using error::e_usage;
int String = 1;
int Int = 2;
int Float = 3;
int Bool = 4;

_Attributes::_Attributes(Dict<Str*, runtime_asdl::value_t*>* defaults) {
  this->attrs = Alloc<Dict<Str*, runtime_asdl::value_t*>>();
  this->opt_changes = Alloc<List<Tuple2<Str*, bool>*>>();
  this->shopt_changes = Alloc<List<Tuple2<Str*, bool>*>>();
  this->show_options = false;
  this->actions = Alloc<List<Str*>>();
  this->saw_double_dash = false;
  for (DictIter<Str*, runtime_asdl::value_t*> it(defaults); !it.Done(); it.Next()) {
    Str* name = it.Key();
    runtime_asdl::value_t* v = it.Value();
    this->Set(name, v);
  }
}

void _Attributes::SetTrue(Str* name) {
  StackRoots _roots({&name});

  this->Set(name, Alloc<value::Bool>(true));
}

void _Attributes::Set(Str* name, runtime_asdl::value_t* val) {
  StackRoots _roots({&name, &val});

  name = name->replace(str97, str98);
  this->attrs->set(name, val);
}

Reader::Reader(List<Str*>* argv, List<syntax_asdl::CompoundWord*>* locs) {
  this->argv = argv;
  this->locs = locs;
  this->n = len(argv);
  this->i = 0;
}

void Reader::Next() {
  this->i += 1;
}

Str* Reader::Peek() {
  if (this->i >= this->n) {
    return nullptr;
  }
  else {
    return this->argv->index_(this->i);
  }
}

Tuple2<Str*, syntax_asdl::loc_t*> Reader::Peek2() {
  if (this->i >= this->n) {
    return Tuple2<Str*, syntax_asdl::loc_t*>(nullptr, loc::Missing);
  }
  else {
    return Tuple2<Str*, syntax_asdl::loc_t*>(this->argv->index_(this->i), this->locs->index_(this->i));
  }
}

Str* Reader::ReadRequired(Str* error_msg) {
  Str* arg = nullptr;
  StackRoots _roots({&error_msg, &arg});

  arg = this->Peek();
  if (arg == nullptr) {
    e_usage(error_msg, this->_FirstLocation());
  }
  this->Next();
  return arg;
}

Tuple2<Str*, syntax_asdl::loc_t*> Reader::ReadRequired2(Str* error_msg) {
  Str* arg = nullptr;
  syntax_asdl::CompoundWord* location = nullptr;
  StackRoots _roots({&error_msg, &arg, &location});

  arg = this->Peek();
  if (arg == nullptr) {
    e_usage(error_msg, this->_FirstLocation());
  }
  location = this->locs->index_(this->i);
  this->Next();
  return Tuple2<Str*, syntax_asdl::loc_t*>(arg, location);
}

List<Str*>* Reader::Rest() {
  return this->argv->slice(this->i);
}

Tuple2<List<Str*>*, List<syntax_asdl::CompoundWord*>*> Reader::Rest2() {
  return Tuple2<List<Str*>*, List<syntax_asdl::CompoundWord*>*>(this->argv->slice(this->i), this->locs->slice(this->i));
}

bool Reader::AtEnd() {
  return this->i >= this->n;
}

syntax_asdl::loc_t* Reader::_FirstLocation() {
  if ((this->locs and this->locs->index_(0) != nullptr)) {
    return this->locs->index_(0);
  }
  else {
    return loc::Missing;
  }
}

syntax_asdl::loc_t* Reader::Location() {
  int i;
  if (this->locs) {
    if (this->i == this->n) {
      i = (this->n - 1);
    }
    else {
      i = this->i;
    }
    if (this->locs->index_(i) != nullptr) {
      return this->locs->index_(i);
    }
    else {
      return loc::Missing;
    }
  }
  else {
    return loc::Missing;
  }
}

_Action::_Action() {
  ;  // pass
}

bool _Action::OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out) {
  StackRoots _roots({&attached_arg, &arg_r, &out});

  FAIL(kNotImplemented);  // Python NotImplementedError
}

_ArgAction::_ArgAction(Str* name, bool quit_parsing_flags, List<Str*>* valid) {
  this->name = name;
  this->quit_parsing_flags = quit_parsing_flags;
  this->valid = valid;
}

runtime_asdl::value_t* _ArgAction::_Value(Str* arg, syntax_asdl::loc_t* location) {
  StackRoots _roots({&arg, &location});

  FAIL(kNotImplemented);  // Python NotImplementedError
}

bool _ArgAction::OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out) {
  Str* arg = nullptr;
  runtime_asdl::value_t* val = nullptr;
  StackRoots _roots({&attached_arg, &arg_r, &out, &arg, &val});

  if (attached_arg != nullptr) {
    arg = attached_arg;
  }
  else {
    arg_r->Next();
    arg = arg_r->Peek();
    if (arg == nullptr) {
      e_usage(StrFormat("expected argument to %r", str_concat(str102, this->name)), arg_r->Location());
    }
  }
  val = this->_Value(arg, arg_r->Location());
  out->Set(this->name, val);
  return this->quit_parsing_flags;
}

SetToInt::SetToInt(Str* name) : _ArgAction(name, false, nullptr) {
}

runtime_asdl::value_t* SetToInt::_Value(Str* arg, syntax_asdl::loc_t* location) {
  int i;
  StackRoots _roots({&arg, &location});

  try {
    i = to_int(arg);
  }
  catch (ValueError*) {
    e_usage(StrFormat("expected integer after %s, got %r", str_concat(str104, this->name), arg), location);
  }
  if (i < 0) {
    e_usage(StrFormat("got invalid integer for %s: %s", str_concat(str106, this->name), arg), location);
  }
  return Alloc<value::Int>(i);
}

SetToFloat::SetToFloat(Str* name) : _ArgAction(name, false, nullptr) {
}

runtime_asdl::value_t* SetToFloat::_Value(Str* arg, syntax_asdl::loc_t* location) {
  double f;
  StackRoots _roots({&arg, &location});

  try {
    f = to_float(arg);
  }
  catch (ValueError*) {
    e_usage(StrFormat("expected number after %r, got %r", str_concat(str108, this->name), arg), location);
  }
  if (f < 0) {
    e_usage(StrFormat("got invalid float for %s: %s", str_concat(str110, this->name), arg), location);
  }
  return Alloc<value::Float>(f);
}

SetToString::SetToString(Str* name, bool quit_parsing_flags, List<Str*>* valid) : _ArgAction(name, quit_parsing_flags, valid) {
}

runtime_asdl::value_t* SetToString::_Value(Str* arg, syntax_asdl::loc_t* location) {
  StackRoots _roots({&arg, &location});

  if ((this->valid != nullptr and !list_contains(this->valid, arg))) {
    e_usage(StrFormat("got invalid argument %r to %r, expected one of: %s", arg, str_concat(str112, this->name), str113->join(this->valid)), location);
  }
  return Alloc<value::Str>(arg);
}

SetAttachedBool::SetAttachedBool(Str* name) {
  this->name = name;
}

bool SetAttachedBool::OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out) {
  bool b;
  StackRoots _roots({&attached_arg, &arg_r, &out});

  if (attached_arg != nullptr) {
    if ((str_equals(attached_arg, str114) || str_equals(attached_arg, str115) || str_equals(attached_arg, str116) || str_equals(attached_arg, str117))) {
      b = false;
    }
    else {
      if ((str_equals(attached_arg, str118) || str_equals(attached_arg, str119) || str_equals(attached_arg, str120) || str_equals(attached_arg, str121))) {
        b = true;
      }
      else {
        e_usage(StrFormat("got invalid argument to boolean flag: %r", attached_arg), loc::Missing);
      }
    }
  }
  else {
    b = true;
  }
  out->Set(this->name, Alloc<value::Bool>(b));
  return false;
}

SetToTrue::SetToTrue(Str* name) {
  this->name = name;
}

bool SetToTrue::OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out) {
  StackRoots _roots({&attached_arg, &arg_r, &out});

  out->SetTrue(this->name);
  return false;
}

SetOption::SetOption(Str* name) {
  this->name = name;
}

bool SetOption::OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out) {
  bool b;
  StackRoots _roots({&attached_arg, &arg_r, &out});

  b = maybe_str_equals(attached_arg, str123);
  out->opt_changes->append((Alloc<Tuple2<Str*, bool>>(this->name, b)));
  return false;
}

SetNamedOption::SetNamedOption(bool shopt) {
  this->names = Alloc<List<Str*>>();
  this->shopt = shopt;
}

void SetNamedOption::ArgName(Str* name) {
  StackRoots _roots({&name});

  this->names->append(name);
}

bool SetNamedOption::OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out) {
  bool b;
  Str* arg = nullptr;
  Str* attr_name = nullptr;
  List<Tuple2<Str*, bool>*>* changes = nullptr;
  StackRoots _roots({&attached_arg, &arg_r, &out, &arg, &attr_name, &changes});

  b = maybe_str_equals(attached_arg, str124);
  arg_r->Next();
  arg = arg_r->Peek();
  if (arg == nullptr) {
    out->show_options = true;
    return true;
  }
  attr_name = arg;
  if ((len(this->names) and !list_contains(this->names, attr_name))) {
    e_usage(StrFormat("Invalid option %r", arg), loc::Missing);
  }
  changes = this->shopt ? out->shopt_changes : out->opt_changes;
  changes->append((Alloc<Tuple2<Str*, bool>>(attr_name, b)));
  return false;
}

SetAction::SetAction(Str* name) {
  this->name = name;
}

bool SetAction::OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out) {
  StackRoots _roots({&attached_arg, &arg_r, &out});

  out->actions->append(this->name);
  return false;
}

SetNamedAction::SetNamedAction() {
  this->names = Alloc<List<Str*>>();
}

void SetNamedAction::ArgName(Str* name) {
  StackRoots _roots({&name});

  this->names->append(name);
}

bool SetNamedAction::OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out) {
  Str* arg = nullptr;
  Str* attr_name = nullptr;
  StackRoots _roots({&attached_arg, &arg_r, &out, &arg, &attr_name});

  arg_r->Next();
  arg = arg_r->Peek();
  if (arg == nullptr) {
    e_usage(str126, loc::Missing);
  }
  attr_name = arg;
  if ((len(this->names) and !list_contains(this->names, attr_name))) {
    e_usage(StrFormat("Invalid action name %r", arg), loc::Missing);
  }
  out->actions->append(attr_name);
  return false;
}

args::_Attributes* Parse(flag_spec::_FlagSpec* spec, args::Reader* arg_r) {
  args::_Attributes* out = nullptr;
  Str* arg = nullptr;
  int pos;
  Str* suffix = nullptr;
  Str* flag_name = nullptr;
  args::_Action* action = nullptr;
  int n;
  Str* ch = nullptr;
  Str* attached_arg = nullptr;
  StackRoots _roots({&spec, &arg_r, &out, &arg, &suffix, &flag_name, &action, &ch, &attached_arg});

  out = Alloc<_Attributes>(spec->defaults);
  while (!arg_r->AtEnd()) {
    arg = arg_r->Peek();
    if (maybe_str_equals(arg, str128)) {
      out->saw_double_dash = true;
      arg_r->Next();
      break;
    }
    if ((len(spec->actions_long) and arg->startswith(str129))) {
      pos = arg->find(str130, 2);
      if (pos == -1) {
        suffix = nullptr;
        flag_name = arg->slice(2);
      }
      else {
        suffix = arg->slice((pos + 1));
        flag_name = arg->slice(2, pos);
      }
      action = spec->actions_long->get(flag_name);
      if (action == nullptr) {
        e_usage(StrFormat("got invalid flag %r", arg), arg_r->Location());
      }
      action->OnMatch(suffix, arg_r, out);
      arg_r->Next();
      continue;
    }
    else {
      if ((arg->startswith(str132) and len(arg) > 1)) {
        n = len(arg);
        for (int i = 1; i < n; ++i) {
          ch = arg->index_(i);
          if (str_equals(ch, str133)) {
            ch = str134;
          }
          if (list_contains(spec->plus_flags, ch)) {
            out->Set(ch, Alloc<value::Str>(str135));
            continue;
          }
          if (list_contains(spec->arity0, ch)) {
            out->SetTrue(ch);
            continue;
          }
          if (dict_contains(spec->arity1, ch)) {
            action = spec->arity1->index_(ch);
            attached_arg = i < (n - 1) ? arg->slice((i + 1)) : nullptr;
            action->OnMatch(attached_arg, arg_r, out);
            break;
          }
          e_usage(StrFormat("doesn't accept flag %s", str_concat(str137, ch)), arg_r->Location());
        }
        arg_r->Next();
      }
      else {
        if ((len(spec->plus_flags) and (arg->startswith(str138) and len(arg) > 1))) {
          n = len(arg);
          for (int i = 1; i < n; ++i) {
            ch = arg->index_(i);
            if (list_contains(spec->plus_flags, ch)) {
              out->Set(ch, Alloc<value::Str>(str139));
              continue;
            }
            e_usage(StrFormat("doesn't accept option %s", str_concat(str141, ch)), arg_r->Location());
          }
          arg_r->Next();
        }
        else {
          break;
        }
      }
    }
  }
  return out;
}

args::_Attributes* ParseLikeEcho(flag_spec::_FlagSpec* spec, args::Reader* arg_r) {
  args::_Attributes* out = nullptr;
  Str* arg = nullptr;
  Str* chars = nullptr;
  bool done;
  StackRoots _roots({&spec, &arg_r, &out, &arg, &chars});

  out = Alloc<_Attributes>(spec->defaults);
  while (!arg_r->AtEnd()) {
    arg = arg_r->Peek();
    chars = arg->slice(1);
    if ((arg->startswith(str142) and len(chars))) {
      done = false;
      for (StrIter it(chars); !it.Done(); it.Next()) {
        Str* c = it.Value();
        StackRoots _for({&c      });
        if (!list_contains(spec->arity0, c)) {
          done = true;
          break;
        }
      }
      if (done) {
        break;
      }
      for (StrIter it(chars); !it.Done(); it.Next()) {
        Str* ch = it.Value();
        StackRoots _for({&ch      });
        out->SetTrue(ch);
      }
    }
    else {
      break;
    }
    arg_r->Next();
  }
  return out;
}

args::_Attributes* ParseMore(flag_spec::_FlagSpecAndMore* spec, args::Reader* arg_r) {
  args::_Attributes* out = nullptr;
  bool quit;
  Str* arg = nullptr;
  args::_Action* action = nullptr;
  Str* char0 = nullptr;
  Str* attached_arg = nullptr;
  StackRoots _roots({&spec, &arg_r, &out, &arg, &action, &char0, &attached_arg});

  out = Alloc<_Attributes>(spec->defaults);
  quit = false;
  while (!arg_r->AtEnd()) {
    arg = arg_r->Peek();
    if (maybe_str_equals(arg, str143)) {
      out->saw_double_dash = true;
      arg_r->Next();
      break;
    }
    if (arg->startswith(str144)) {
      action = spec->actions_long->get(arg->slice(2));
      if (action == nullptr) {
        e_usage(StrFormat("got invalid flag %r", arg), arg_r->Location());
      }
      action->OnMatch(nullptr, arg_r, out);
      arg_r->Next();
      continue;
    }
    if (((arg->startswith(str146) or arg->startswith(str147)) and len(arg) > 1)) {
      char0 = arg->index_(0);
      for (StrIter it(arg->slice(1)); !it.Done(); it.Next()) {
        Str* ch = it.Value();
        StackRoots _for({&ch      });
        action = spec->actions_short->get(ch);
        if (action == nullptr) {
          e_usage(StrFormat("got invalid flag %r", str_concat(str149, ch)), arg_r->Location());
        }
        attached_arg = list_contains(spec->plus_flags, ch) ? char0 : nullptr;
        quit = action->OnMatch(attached_arg, arg_r, out);
      }
      arg_r->Next();
      if (quit) {
        break;
      }
      else {
        continue;
      }
    }
    break;
  }
  return out;
}

}  // define namespace args

