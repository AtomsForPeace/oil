# yaks IR: An idea to replace tea/, removing all the tea_* productions from
# ysh/grammar.pgen2.
#
# This is basically the subset of C++ we generate.
# 
# Issues with mycpp I want to address:
#
# - speed of Python dev build
#   - type check and run Python in 1 second
# - speed of C++ build
#   - type check, generate multiple C++ MODULES, compile the whole program in
#     say 5-10 seconds.  I think it's more like 30 seconds now.
# - rooting: can be optimize it, not generate 480 KB of StackRoots or wahtever
#   - this requires analyzing the call graph
# - MODULES and dependencies -- may require re-organizing the Oils codebase
# itself.
#   - cpp/preamble.h is a hack.
#   - This includes things like "system" deps like ENOENT and fork(), etc.
#
# MAYBE:
# - Can we generate value types in C++, to reduce GC pressure?  Is that done
#   with a new ASDL keyword?
#
# The Yaks IR can be generated from:
# 1. typed Python 2, like mycpp.  This can be done with the Python 3.8 AST,
#    like pea/
#    - we have a speed test of parsing in parallel in 300 ms or so
#
# Much later:
#
# 1. Some kind of Tea/ typed YSH syntax?  To write builtins in YSH, with typed
#   'case' syntax?
#   - better context manager / constructor-destructor syntax?
#   - value types?
#   - but there is no syntax for data types in YSH.
#     - I think those are DYNAMIC SCHEMAS
#     - We can keep ASDL though.
# 2. If mycpp has a universal string type, and maybe double support:
#    - TypeScript/JavaScript.  See oilshell/yaks experiment.
#    - Python 3 with unicode string/byte semantics
#      - we have a supported interpreter and tooling
#    - Universal string type would use the PyPy utf-8 and utf-16 indices:
#    64-byte blocks.
#
# Sketch of compilation pipeline:
# 1. Create a CST language that can be hand-written or generated
# 2. It can be transformed to this yaks.asdl, in the style of
#    oilshell/yaks/transform.ts Precedence is unambiguous (+ 1 2)
# 3. Go through the stages in mycpp/README.md, but PER MODULE
#    a. const pass for GLOBAL_STR -- immutable literals
#    b. forward decl pass
#    c. declaration/function prototype pass
#       - GC Masks are generated from this typed IR.  It knows about pointers
#       and so forth
#    d. implementation pass
# 4. Then all the C++ goes into Ninja, as usual.

module yaks
{
  expr =
    Int(int i)
  | Float(float f)

  # Is this representation type checked directly?  I guess that would help.
  # But Pea is also type checked?
  type =
    Atom()
  | Compound()

  stmt =
    VarDecl()  # int i = 0
  | PlaceMutation()  # x = y

  | If()
  | Switch()  # generated by with tagswitch
  | For()
  | While()

  | Try()

  | With()  # Scoped destruction

    # These are at the module level?
  | Func()
  | Class()  # classes contain methods, can be generated by ASDL too

  # This is list of globals, class/method definitions, and functions.
  # It has DEPS (to be worked out)
  Module = ()

  # These are different because we know the size at compile time.
  #
  # GLOBAL_STR()
  # GLOBAL_LIST()
  # GLOBAL_DICT()

  # There's also the idea of taking an entire parsed ASDL structure and making
  # it global!
  # I guess if you have these 3, it's not that hard.  You just need
  # GLOBAL_CLASS(MyClass, {...}).  It will probably bloat the binary
  # considerably, but could be the best solution.
}

# vim: sw=2
